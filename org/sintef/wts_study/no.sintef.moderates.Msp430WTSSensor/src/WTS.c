
/*
 * Generated using the EDAP MDE Framework (C)SINTEF
 *
 *     ****    DO NOT EDIT THIS FILE    ****
 *
 * Application : WTS 
 *    Platform : Texas Instruments MSP430 Microcontroller
 *        Date : ???
 *      Author : SINTEF
 *     License : EPL
 */
 #include  "msp430x22x4.h"


#include  "msp430x22x4.h"
#include <signal.h>
#include <stdlib.h>
#include <string.h>


/******************************************************************************
 *                           INCLUDE THE DEVICES
 ******************************************************************************/
 
#include "WTSClient.h" 
#include "Timer.h" 
#include "MSP430Sensor.h" 
#include "LED.h" 

/******************************************************************************
 *                      CODE FROM THE GLOBALS TEMPLATE
 ******************************************************************************/



char name[8];

static int temp;
static int batt;

static int min;
static int max;
static int interval;

static int interval_cpt;

static int min_alarm;
static int max_alarm;
static int bat_alarm;



/******************************************************************************
 *                            STATES DECLARATION
 ******************************************************************************/
// Define all the states and their IDs
#define EDAP_STATE_WTS_0 0	// fixed
#define EDAP_STATE_INIT_2 2
#define EDAP_STATE_ACTIVE_1 1
#define EDAP_STATE_WAITINGFORCMD_3 3
#define EDAP_STATE_READSENSORVALUES_4 4

// Static variable to store the current state of the state machines and composites
static int EDAP_STATE_WTS_0_Current_State[2];

/******************************************************************************
 *                          PROTOTYPES DECLARATION
 ******************************************************************************/

// Prototypes for Entry actions
void EDAP_STATE_WTS_0_EDAP_STATE_INIT_2_On_Entry();
void EDAP_STATE_WTS_0_EDAP_STATE_ACTIVE_1_On_Entry();
void EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
void EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Entry();

// Prototypes for Exit actions
void EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Exit();

// Prototypes for Events handlers
void EDAP_STATE_WTS_0_GetStatus_Event_Handler();
void EDAP_STATE_WTS_0_SetInterval_Event_Handler(int value);
void EDAP_STATE_WTS_0_timeout_Event_Handler(int timer_id);
void EDAP_STATE_WTS_0_temperature_value_Event_Handler(int v);
void EDAP_STATE_WTS_0_SetMaxAlarm_Event_Handler(int value);
void EDAP_STATE_WTS_0_SetBattAlarm_Event_Handler(int value);
void EDAP_STATE_WTS_0_SetName_Event_Handler(char * new_name);
void EDAP_STATE_WTS_0_GetData_Event_Handler();
void EDAP_STATE_WTS_0_voltage_value_Event_Handler(int v);
void EDAP_STATE_WTS_0_SetMinAlarm_Event_Handler(int value);
void EDAP_STATE_WTS_0_ResetMinMax_Event_Handler();
void EDAP_STATE_WTS_0_GetName_Event_Handler();

/******************************************************************************
 *                    IMPLEMENTATION OF ENTRY AND EXIT
 ******************************************************************************/
 
// Entry actions
void EDAP_STATE_WTS_0_EDAP_STATE_ACTIVE_1_On_Entry() {
	EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] = EDAP_STATE_READSENSORVALUES_4; // no history
	
	EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Entry();
}
void EDAP_STATE_WTS_0_EDAP_STATE_INIT_2_On_Entry() {
	{
Timer_send_start(1, 1000);
LED_send_light_on(1);
LED_send_light_on(2);
min_alarm = 260;
max_alarm = 190;
bat_alarm = 30;
interval = 0;
interval_cpt = 0;
strcpy(name, "No name ");
}
}
void EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry() {
	{
Timer_send_start(1, 10000);
}
}
void EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Entry() {
	{
LED_send_light_on(2);
MSP430Sensor_send_mesure_temperature();
}
}

// Exit actions
void EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Exit(){
	{
LED_send_light_off(2);
interval_cpt++;
if (interval != 0 && interval_cpt >= interval) {
WTSClient_send_SensorData(temp, min, max, batt);
interval_cpt = 0;
}
}
}

 /******************************************************************************
 *                    IMPLEMENTATION OF EVENT HANDLING
 ******************************************************************************/
 
void EDAP_STATE_WTS_0_GetStatus_Event_Handler(){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		WTSClient_send_SensorStatus(interval, min_alarm, max_alarm, bat_alarm);
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_SetInterval_Event_Handler(int value){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		interval = value;
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_timeout_Event_Handler(int timer_id){
		if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_INIT_2 &&
		timer_id == 1 ) {
		
		{
LED_send_light_off(1);
LED_send_light_off(2);
}
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] = EDAP_STATE_ACTIVE_1; // change state
		EDAP_STATE_WTS_0_EDAP_STATE_ACTIVE_1_On_Entry();
		return; // The event has been consumed
	}
if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 &&
		timer_id == 1 ) {
		
		
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] = EDAP_STATE_READSENSORVALUES_4; // change state
		EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Entry();
		return; // The event has been consumed
	}
}
void EDAP_STATE_WTS_0_temperature_value_Event_Handler(int v){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_READSENSORVALUES_4 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Exit();
		{
temp = v;
if (temp > max) max = temp;
if (temp < min) min = temp;
MSP430Sensor_send_mesure_voltage();
}
		EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_SetMaxAlarm_Event_Handler(int value){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		max_alarm = value;
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_SetBattAlarm_Event_Handler(int value){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		bat_alarm = value;
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_SetName_Event_Handler(char * new_name){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		strcpy(name, new_name);
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_GetData_Event_Handler(){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		WTSClient_send_SensorData(temp, min, max, batt);
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_voltage_value_Event_Handler(int v){
		if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_READSENSORVALUES_4 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		EDAP_STATE_WTS_0_EDAP_STATE_READSENSORVALUES_4_On_Exit();
		batt = v;
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] = EDAP_STATE_WAITINGFORCMD_3; // change state
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
}
void EDAP_STATE_WTS_0_SetMinAlarm_Event_Handler(int value){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		min_alarm = value;
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_ResetMinMax_Event_Handler(){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		min = temp; max = temp;
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}
void EDAP_STATE_WTS_0_GetName_Event_Handler(){
	if ( EDAP_STATE_WTS_0_Current_State[EDAP_STATE_ACTIVE_1] == EDAP_STATE_WAITINGFORCMD_3 &&
		EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] == EDAP_STATE_ACTIVE_1 ) {
		
		WTSClient_send_SensorName(name);
		EDAP_STATE_WTS_0_EDAP_STATE_WAITINGFORCMD_3_On_Entry();
		return; // The event has been consumed
	}
	}

 /******************************************************************************
 *                        INITIALISATION AND MAIN
 ******************************************************************************/

int main () {


	int i;
	// Stop watchdog timer
	WDTCTL = WDTPW + WDTHOLD;
	
	// Set the clock
	BCSCTL1 = CALBC1_8MHZ;
	DCOCTL = CALDCO_8MHZ;
	BCSCTL3 |= LFXT1S_2;


	
	// initialize devices
	init_WTSClient();
	init_LED();
	init_Timer();
	init_RF2500();
	
	// register state machine event handlers
	register_WTSClient_receive_GetStatus_listener(EDAP_STATE_WTS_0_GetStatus_Event_Handler);
	register_WTSClient_receive_SetInterval_listener(EDAP_STATE_WTS_0_SetInterval_Event_Handler);
	register_Timer_receive_timeout_listener(EDAP_STATE_WTS_0_timeout_Event_Handler);
	register_MSP430Sensor_receive_temperature_value_listener(EDAP_STATE_WTS_0_temperature_value_Event_Handler);
	register_WTSClient_receive_SetMaxAlarm_listener(EDAP_STATE_WTS_0_SetMaxAlarm_Event_Handler);
	register_WTSClient_receive_SetBattAlarm_listener(EDAP_STATE_WTS_0_SetBattAlarm_Event_Handler);
	register_WTSClient_receive_SetName_listener(EDAP_STATE_WTS_0_SetName_Event_Handler);
	register_WTSClient_receive_GetData_listener(EDAP_STATE_WTS_0_GetData_Event_Handler);
	register_MSP430Sensor_receive_voltage_value_listener(EDAP_STATE_WTS_0_voltage_value_Event_Handler);
	register_WTSClient_receive_SetMinAlarm_listener(EDAP_STATE_WTS_0_SetMinAlarm_Event_Handler);
	register_WTSClient_receive_ResetMinMax_listener(EDAP_STATE_WTS_0_ResetMinMax_Event_Handler);
	register_WTSClient_receive_GetName_listener(EDAP_STATE_WTS_0_GetName_Event_Handler);

	// Initialize state machine
	EDAP_STATE_WTS_0_Current_State[EDAP_STATE_WTS_0] = EDAP_STATE_INIT_2; // Set the initial state
	EDAP_STATE_WTS_0_EDAP_STATE_INIT_2_On_Entry();
	
	__enable_interrupt();  // IMPORTANT :-)
	
	while(1) {
		int i;
		
	// some sort of polling delay
	for(i=50000; i>0; i--) __no_operation();

		// poll the drivers
		poll_WTSClient();
		poll_Timer();
		poll_RF2500();
		poll_MSP430Sensor();
	}
}
