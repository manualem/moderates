package thingML;
require kermeta
require "platform:/lookup/org.sintef.edap.model/model/edap.ecore"
require "../stringHelper.kmt"
using kermeta::standard
using kermeta::utils
class ProtocolGenerator{
operation generate(packageName:String, device:edap::Device, root:edap::EdapModel):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("")
var helper : StringHelper init StringHelper.new
_res.append("package ")
_res.append(packageName)
_res.append(";\n\nimport java.util.Hashtable;\nimport ")
_res.append(packageName)
_res.append(".in.*;\nimport ")
_res.append(packageName)
_res.append(".out.*;\n\npublic abstract class ")
_res.append(device.name)
_res.append("Protocol {\n\n\t//Enumerations\n")
root.types.select{t | t.isKindOf(edap::Enumeration)}.each{ e | 
_res.append("\tpublic static enum ")
_res.append(e.name)
_res.append("{\t\n\t\t")
var x : Integer init 0 e.asType(edap::Enumeration).literals.each{l | if x > 0 then
_res.append(",\n\t\t")
end
_res.append(l.name)
_res.append("(\"")
_res.append(helper.getValue(l))
_res.append("\")")
x := x+1}
_res.append(";\n\t\n\t\tprivate final String value;\n\t\t")
_res.append(e.name)
_res.append("(String value){\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\tpublic String getValue(){\n\t\t\treturn value;\n\t\t}\n\t}\n")
}
_res.append("\n\t// Outgoing messages\n")
device.receives.each{out | 
_res.append("\tpublic static final byte ")
_res.append(helper.toJavaConstant(out.name))
_res.append(" = ")
_res.append(out.annotations.select{a | a.name == "code"}.one.~value)
_res.append("; \n")
}
_res.append("\t\n\t// incoming messages\n")
device.sends.each{in | 
_res.append("\tpublic static final byte ")
_res.append(helper.toJavaConstant(in.name))
_res.append(" = ")
_res.append(in.annotations.select{a | a.name == "code"}.one.~value)
_res.append("; \n")
}
_res.append("\t\n\n\tprivate static Hashtable<Byte, Incoming")
_res.append(device.name)
_res.append("Message> incomingMsg;\n\t\n\tprivate static void createincomingMsg() {\n\t\tincomingMsg = new Hashtable<Byte, Incoming")
_res.append(device.name)
_res.append("Message>();\n")
device.sends.each{in | 
_res.append("\t\tincomingMsg.put(")
_res.append(device.name)
_res.append("Protocol.")
_res.append(helper.toJavaConstant(in.name))
_res.append(", new ")
_res.append(in.name)
_res.append("_In()); \n")
}
_res.append("")
device.receives.each{in | 
_res.append("\t\tincomingMsg.put(")
_res.append(device.name)
_res.append("Protocol.")
_res.append(helper.toJavaConstant(in.name))
_res.append(", new ")
_res.append(in.name)
_res.append("_In()); \n")
}
_res.append("\t}\n\t\n\tpublic static Incoming")
_res.append(device.name)
_res.append("Message createMessageForIncomingPacket(byte[] packet) {\n\t\tif(incomingMsg == null) createincomingMsg();\n\t\tbyte packetType = packet[4];\n\t\tIncoming")
_res.append(device.name)
_res.append("Message result = null;\n\t\tif (incomingMsg.containsKey(packetType)) {\n\t\t\tresult = incomingMsg.get(packetType).createPacket(packet);\n\t\t}\n\t\treturn result;\n\t}\n\n")
device.receives.each{out | 
_res.append("\tpublic static ")
_res.append(out.name)
_res.append("_Out create")
_res.append(out.name)
_res.append("(")
_res.append(helper.paramsToJava(out))
_res.append(") {\n\t\t")
_res.append(out.name)
_res.append("_Out result = new ")
_res.append(out.name)
_res.append("_Out(")
_res.append(helper.paramsToJavaCall(out))
_res.append(");\n\t\treturn result;\n\t}\n\t\n")
}
_res.append("\t\n")
device.sends.each{out | 
_res.append("\tpublic static ")
_res.append(out.name)
_res.append("_Out create")
_res.append(out.name)
_res.append("(")
_res.append(helper.paramsToJava(out))
_res.append(") {\n\t\t")
_res.append(out.name)
_res.append("_Out result = new ")
_res.append(out.name)
_res.append("_Out(")
_res.append(helper.paramsToJavaCall(out))
_res.append(");\n\t\treturn result;\n\t}\n\t\n")
}
_res.append("}\n")
result := _res.toString
end
}
