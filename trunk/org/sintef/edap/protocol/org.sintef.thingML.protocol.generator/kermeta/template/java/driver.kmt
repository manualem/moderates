package thingML;
require kermeta
require "../../stringHelper.kmt"
using kermeta::standard
using kermeta::utils
class DriverGenerator{
operation generate(packageName:String, device:edap::Device, root:edap::EdapModel):String is do
var _res: StringBuffer init StringBuffer.new
_res.append("")
var helper : StringHelper init StringHelper.new
_res.append("/**\n * Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 3, 29 June 2007;\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * \thttp://www.gnu.org/licenses/lgpl-3.0.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Authors: Franck Fleurey and Brice Morin\n * Company: SINTEF IKT, Oslo, Norway\n * Date: 2011\n */\npackage ")
_res.append(packageName)
_res.append(";\n\nimport ")
_res.append(packageName)
_res.append(".msg.*;\nimport ")
_res.append(packageName)
_res.append(".comm.*;\nimport ")
_res.append(packageName)
_res.append(".observer.*;\n\npublic abstract class Abstract")
_res.append(device.name)
_res.append(" {\n\n\tprivate ")
_res.append(device.name)
_res.append("DriverMessageHandler messageHandler;\n\tprivate Serial4")
_res.append(device.name)
_res.append(" serial;\n\n\tpublic Abstract")
_res.append(device.name)
_res.append("(String port) {\n\t\tserial = new Serial4")
_res.append(device.name)
_res.append("(port);\n\t\tmessageHandler = new ")
_res.append(device.name)
_res.append("DriverMessageHandler();\n\t\tserial.register(messageHandler);\n\t}\n\t\n\t//*************************************************************************\n\t// Asynchronous remote calls. No expected result or ack. \"Send and forget\" \n\t//*************************************************************************\n")
device.receives_async.each{ m | 
_res.append("\tpublic void ")
_res.append(m.name)
_res.append("(")
_res.append(helper.paramsToJava(m))
_res.append(") {\n\t\t// Create message using the factory\n\t\tFixedSizePacket p = ")
_res.append(device.name)
_res.append("Protocol.create")
_res.append(helper.firstToUpper(m.name))
_res.append("(")
_res.append(helper.paramsToJavaCall(m))
_res.append(");\n\t\t// Send the message on the serial line\n\t\tserial.receiveMsg(p.getPacket());\n\t}\n")
}
_res.append("\t\n\t//*************************************************************************\n\t// Synchronous remote calls. Wait for the ack and return true if it comes\n\t//*************************************************************************\n")
device.receives_sync_ack.each{ m | 
_res.append("\tprivate boolean ")
_res.append(m.name)
_res.append("_ack_available;\n\tprivate final Object ")
_res.append(m.name)
_res.append("Monitor = \"")
_res.append(m.name)
_res.append("Monitor\";\n\tpublic boolean ")
_res.append(m.name)
_res.append("(")
_res.append(helper.paramsToJava(m))
_res.append(") {\n\t\t")
_res.append(m.name)
_res.append("_ack_available = false;\n\t\t// Create message using the factory\n\t\tFixedSizePacket p = ")
_res.append(device.name)
_res.append("Protocol.create")
_res.append(helper.firstToUpper(m.name))
_res.append("(")
_res.append(helper.paramsToJavaCall(m))
_res.append(");\n\t\t// Create message using the factory\n\t\tserial.receiveMsg(p.getPacket());\n\t\ttry {\n\t\t\tsynchronized(")
_res.append(m.name)
_res.append("Monitor) {\n\t\t\t\t")
_res.append(m.name)
_res.append("Monitor.wait(")
_res.append(m.timeout_annotation)
_res.append(");\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (")
_res.append(m.name)
_res.append("_ack_available) return true;\n\t\telse return false;\n\t}\n")
}
_res.append("\t\n\t//*************************************************************************\n\t// Synchronous remote calls with result\n\t//*************************************************************************\n")
device.receives_sync_response.each{ m | 
_res.append("\tprivate ")
_res.append(helper.toJavaType(m.sync_response_parameter.type))
_res.append(" ")
_res.append(m.name)
_res.append("_result;\n\tprivate boolean ")
_res.append(m.name)
_res.append("_result_available;\n\tprivate final Object ")
_res.append(m.name)
_res.append("Monitor = \"")
_res.append(m.name)
_res.append("Monitor\";\n\tpublic ")
_res.append(helper.toJavaType(m.sync_response_parameter.type))
_res.append(" ")
_res.append(m.name)
_res.append("(")
_res.append(helper.paramsToJava(m))
_res.append(") {\n\t\ttry {\n\t\t\tsynchronized(")
_res.append(m.name)
_res.append("Monitor) {\n\t\t\t\t")
_res.append(m.name)
_res.append("_result_available = false;\n\t\t\t\t// Create message using the factory\n\t\t\t\tFixedSizePacket p = ")
_res.append(device.name)
_res.append("Protocol.create")
_res.append(helper.firstToUpper(m.name))
_res.append("(")
_res.append(helper.paramsToJavaCall(m))
_res.append(");\n\t\t\t\t// Create message using the factory\n\t\t\t\tserial.receiveMsg(p.getPacket());\n\t\t\t\t")
_res.append(m.name)
_res.append("Monitor.wait(")
_res.append(m.timeout_annotation)
_res.append(");\n\t\t\t\tif (")
_res.append(m.name)
_res.append("_result_available) return ")
_res.append(m.name)
_res.append("_result;\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t// The exception alternative\n\t\t//throw new Error(\"")
_res.append(device.name)
_res.append(": Timeout waiting for the result of ")
_res.append(m.name)
_res.append("\");\n\t\t// The error message alternative\n\t\tSystem.err.println(\"")
_res.append(device.name)
_res.append(": Timeout waiting for the result of ")
_res.append(m.name)
_res.append("\");\n")
 if helper.getJavaByteTypes().contains(helper.toJavaType(m.sync_response_parameter.type)) then
_res.append("\t\treturn 0;\n")
else
_res.append("\t\treturn null;\n")
end
_res.append("\t\t\n\t}\n")
}
_res.append("\t\n\t/* ******************************************************\n\t * Handlers for the incoming messages\n\t ********************************************************/\n")
device.sends_async.each{ m | 
_res.append("\t/**\n\t * Implement this method to handle the incoming message ")
_res.append(m.name)
_res.append("\n\t */\n\tprotected abstract void receive")
_res.append(helper.firstToUpper(m.name))
_res.append("(")
_res.append(helper.paramsToJava(m))
_res.append(");\n")
}
_res.append("\t\n\tprivate class ")
_res.append(device.name)
_res.append("DriverMessageHandler extends ")
_res.append(device.name)
_res.append("MessageHandler implements ")
_res.append(device.name)
_res.append("Observer {\n\t\t\n\t\t@Override\n\t\t// Messages from the ")
_res.append(device.name)
_res.append(" device arrive here\n\t\tpublic void receiveMsg(byte[] msg) {\n\t\t\t")
_res.append(device.name)
_res.append("ProtocolPacket p = (")
_res.append(device.name)
_res.append("ProtocolPacket)")
_res.append(device.name)
_res.append("Protocol.createMessageFromPacket(msg);\n\t\t\tp.acceptHandler(messageHandler);\n\t\t}\n\t\t\n\t\t//*************************************************************************\n\t\t// Results of Synchronous remote calls with results\n\t\t//*************************************************************************\n")
device.receives_sync_response.each{ m | 
_res.append("\t\t@Override\n\t\tpublic void handle")
_res.append(helper.firstToUpper(m.sync_response_message.name))
_res.append("(")
_res.append(helper.firstToUpper(m.sync_response_message.name))
_res.append(" msg) {\n\t\t\t")
_res.append(m.name)
_res.append("_result = msg.get")
_res.append(helper.firstToUpper(m.sync_response_parameter.name))
_res.append("();\n\t\t\t")
_res.append(m.name)
_res.append("_result_available = true;\n\t\t\tsynchronized(")
_res.append(m.name)
_res.append("Monitor) {\n\t\t\t\t")
_res.append(m.name)
_res.append("Monitor.notify();\n\t\t\t}\n\t\t}\n")
}
_res.append("\t\t\n\t\t//*************************************************************************\n\t\t// Results of Synchronous remote calls with acks\n\t\t//*************************************************************************\n")
device.receives_sync_ack.each{ m | 
_res.append("\t\t@Override\n\t\tpublic void handle")
_res.append(helper.firstToUpper(m.sync_ack_message.name))
_res.append("(")
_res.append(helper.firstToUpper(m.sync_ack_message.name))
_res.append(" msg) {\n\t\t\tsynchronized(")
_res.append(m.name)
_res.append("Monitor) {\n\t\t\t\t")
_res.append(m.name)
_res.append("_ack_available = true;\n\t\t\t\t")
_res.append(m.name)
_res.append("Monitor.notify();\n\t\t\t}\n\t\t}\n")
}
_res.append("\t\n\t\t//*************************************************************************\n\t\t// Asynchonous incoming messages\n\t\t//*************************************************************************\n")
device.sends_async.each{ m | 
_res.append("\t\t@Override\n\t\tpublic void handle")
_res.append(helper.firstToUpper(m.name))
_res.append("(")
_res.append(helper.firstToUpper(m.name))
_res.append(" msg) {\n\t\t\treceive")
_res.append(helper.firstToUpper(m.name))
_res.append("(")
_res.append(helper.paramsToGetterCall(m, "msg"))
_res.append(");\n\t\t}\n")
}
_res.append("\t}\n}\n")
result := _res.toString
end
}
